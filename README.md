# Java 高级
## Java 多线程 对于Java来说 至少有三个线程 main gc 异常处理
### 程序：是为了完成特定的任务、用某种语言编写的一组指令集合。就是一段静态的代码、静态结构
### 进程：正在有运行的一个程序 有生命周期
### 线程：最小的CPU的处理单位 是一个程序的一条路经 ,一个进程可以有多个线程、这些线程共享相同堆和方法区、每一个线程有单独的程序计数器和虚拟机栈
### 单核CPU：实际上是一种假的多线程，因为在一个时间段内只能执行一个线程
### 多核CPU：可以启用多个核
### 并行：多个CPU同时执行多个任务 多个人做不同的事情
### 并发：一个CPU“同时”执行多个任务、秒杀
### 什么时候创建多线程：程序需要同时执行两个或多个任务、程序需要执行等待的任务时、需要一些后台的程序
## Java创建多线程
#### java.lang.Thread 继承 重写
#### 实现runnable接口、实现run方法
#### 实现callable接口 实现call方法 可以有返回值、方法可以抛出异常、支持泛型的返回值、需要借助FutureTask
#### 线程池 避免频繁创建销毁、实现重复利用。 提高响应速度减少线程创建的时间、便于线程管理 有具体的规定
#### 比较创建线程的两种方法 
##### 开发中优先选择runnable 没有类的单继承性的局限性 实现的方式更适合共享数据的形式
1. Thread也是实现了runnable接口
2. 都需要重写run方法

### 线程的调度
1. 时间片
2. 抢占式 高优先级先
### 线程的分类
1. 守护
2. 主线程
### 线程的声明周期 Thread.state
1. 新建 new
2. 就绪 start
3. 运行
4. 阻塞
5. 死亡
6. 从运行到就绪： 失去cpu的执行权 如调用yield() 不会释放锁
7. 运行到死亡：执行完方法 调用 stop 出现异常没处理
8. 运行到阻塞：sleep() join() 等待同步锁 wait() suspend()挂起可能出现死锁
9. 阻塞到运行：sleep()时间到了 join()对应的线程结束 获取同步锁 notify() notifyAll() resume()结束挂起
### 线程的同步 同步代码块 
### 死锁问题：不同的线程占用对方需要的资源互不放弃，都在等待对方放弃，形成死锁
### 线程之间的通信
## Java常用类
### String
1.public final class String实现了Comparable 每个字符存在一个char型数组内 是final的 不可变性 指向同一个但一个变了其他的不该变
### JVM设计字符串的内存结构
### 堆
1. 新生区
2. 养老区
3. 永久区（永久区）
### StringBuffer可变的字符串
## 枚举类 
## 注解，元注解(注释注释的注释)
### 文档注解
### 编译时 格式检查
## 泛型 允许在定义类、抽象类、接口时  它通过一个标识 来说明类型
## File 对于在单元测试的方法  相对路径 即为当前的Moudle main里面为当前的工程
## IO 字节流：非文本的数据适合  字符流：文本数据比较适合 直接作用在文件上的叫做 节点流 包着流的叫做 处理流
### InputStream OutputStream 字节流 抽象基类
### Reader Writer 字符流抽象基类  不能操作字节流文件 
### 对于英文 一个英文就是一个字节 中文 是三个  文本文件（.txt .java .c .cpp） 非文本文件(.doc .jpg .mp3 .avi .ppt)
## Bufferedxxx 是处理流  更高效  内部提供缓冲区（8192）  调用 flush 清空缓冲区

## 转换流：InputStreamReader 将一个字节的输入流转换为字符流  OutStreamWriter 将一个输出的字符流转换为字节流流  属于字符流  提供字节流和字符流之间的转换
## System.in System.out为标准的输入输出流
## 对象流：用于存取基本数据类型 或 对象的处理流  可以操作对象  
### 序列化：内存里面放到文件内  叫做序列化 要求类可以序列化
### 反序列化： 文件的内容放到内存
## NIO 基于缓冲区 更高效  类内有Path替代原先的File  Paths是Path的工具类 用来获取Path的实例   Files三类

## IP MAC 确定主机 端口号确定 应用
## 反射：动态语言的关键 java 准动态语言
1. 在运行时判断任意对象的所属的类
2. 在运行时构造任意一个类的对象
3. 在运行时判断任意一个类的所具有的成员变量和方法
4. 在运行时获取泛型信息
5. 在运行时调用任意一个类的成员变量和方法
6. 在运行时处理注解
7. 生成动态代理

